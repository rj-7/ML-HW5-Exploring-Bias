{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "d03a966d",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2024-04-26T04:52:44.650560Z",
     "iopub.status.busy": "2024-04-26T04:52:44.650210Z",
     "iopub.status.idle": "2024-04-26T04:52:58.366140Z",
     "shell.execute_reply": "2024-04-26T04:52:58.365038Z"
    },
    "papermill": {
     "duration": 13.727201,
     "end_time": "2024-04-26T04:52:58.368811",
     "exception": false,
     "start_time": "2024-04-26T04:52:44.641610",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2024-04-26 04:52:48.376667: E external/local_xla/xla/stream_executor/cuda/cuda_dnn.cc:9261] Unable to register cuDNN factory: Attempting to register factory for plugin cuDNN when one has already been registered\n",
      "2024-04-26 04:52:48.376790: E external/local_xla/xla/stream_executor/cuda/cuda_fft.cc:607] Unable to register cuFFT factory: Attempting to register factory for plugin cuFFT when one has already been registered\n",
      "2024-04-26 04:52:48.491966: E external/local_xla/xla/stream_executor/cuda/cuda_blas.cc:1515] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import seaborn as sn\n",
    "from tqdm import tqdm\n",
    "import tensorflow as tf\n",
    "import matplotlib.pyplot as plt\n",
    "import math\n",
    "import random\n",
    "import time\n",
    "import keras\n",
    "from keras.datasets import cifar10\n",
    "from keras.utils import to_categorical\n",
    "from keras import models, layers, optimizers, regularizers\n",
    "from keras.models import Model, Sequential\n",
    "from keras.layers import Dense, Dropout, Conv2D, MaxPooling2D, Flatten\n",
    "from skimage.color import rgb2gray\n",
    "import sklearn\n",
    "from sklearn import model_selection, preprocessing, metrics\n",
    "from scipy import stats"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d359573f",
   "metadata": {
    "papermill": {
     "duration": 0.006352,
     "end_time": "2024-04-26T04:52:58.382304",
     "exception": false,
     "start_time": "2024-04-26T04:52:58.375952",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Load and explore dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "4758c7ca",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:52:58.397626Z",
     "iopub.status.busy": "2024-04-26T04:52:58.396974Z",
     "iopub.status.idle": "2024-04-26T04:52:58.430541Z",
     "shell.execute_reply": "2024-04-26T04:52:58.429347Z"
    },
    "papermill": {
     "duration": 0.043766,
     "end_time": "2024-04-26T04:52:58.432766",
     "exception": false,
     "start_time": "2024-04-26T04:52:58.389000",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['F0semitoneFrom27.5Hz_sma3nz_amean',\n",
       " 'F0semitoneFrom27.5Hz_sma3nz_stddevNorm',\n",
       " 'F0semitoneFrom27.5Hz_sma3nz_percentile20.0',\n",
       " 'F0semitoneFrom27.5Hz_sma3nz_percentile50.0',\n",
       " 'F0semitoneFrom27.5Hz_sma3nz_percentile80.0',\n",
       " 'F0semitoneFrom27.5Hz_sma3nz_pctlrange0-2',\n",
       " 'F0semitoneFrom27.5Hz_sma3nz_meanRisingSlope',\n",
       " 'F0semitoneFrom27.5Hz_sma3nz_stddevRisingSlope',\n",
       " 'F0semitoneFrom27.5Hz_sma3nz_meanFallingSlope',\n",
       " 'F0semitoneFrom27.5Hz_sma3nz_stddevFallingSlope',\n",
       " 'loudness_sma3_amean',\n",
       " 'loudness_sma3_stddevNorm',\n",
       " 'loudness_sma3_percentile20.0',\n",
       " 'loudness_sma3_percentile50.0',\n",
       " 'loudness_sma3_percentile80.0',\n",
       " 'loudness_sma3_pctlrange0-2',\n",
       " 'loudness_sma3_meanRisingSlope',\n",
       " 'loudness_sma3_stddevRisingSlope',\n",
       " 'loudness_sma3_meanFallingSlope',\n",
       " 'loudness_sma3_stddevFallingSlope',\n",
       " 'spectralFlux_sma3_amean',\n",
       " 'spectralFlux_sma3_stddevNorm',\n",
       " 'mfcc1_sma3_amean',\n",
       " 'mfcc1_sma3_stddevNorm',\n",
       " 'mfcc2_sma3_amean',\n",
       " 'mfcc2_sma3_stddevNorm',\n",
       " 'mfcc3_sma3_amean',\n",
       " 'mfcc3_sma3_stddevNorm',\n",
       " 'mfcc4_sma3_amean',\n",
       " 'mfcc4_sma3_stddevNorm',\n",
       " 'jitterLocal_sma3nz_amean',\n",
       " 'jitterLocal_sma3nz_stddevNorm',\n",
       " 'shimmerLocaldB_sma3nz_amean',\n",
       " 'shimmerLocaldB_sma3nz_stddevNorm',\n",
       " 'HNRdBACF_sma3nz_amean',\n",
       " 'HNRdBACF_sma3nz_stddevNorm',\n",
       " 'logRelF0-H1-H2_sma3nz_amean',\n",
       " 'logRelF0-H1-H2_sma3nz_stddevNorm',\n",
       " 'logRelF0-H1-A3_sma3nz_amean',\n",
       " 'logRelF0-H1-A3_sma3nz_stddevNorm',\n",
       " 'F1frequency_sma3nz_amean',\n",
       " 'F1frequency_sma3nz_stddevNorm',\n",
       " 'F1bandwidth_sma3nz_amean',\n",
       " 'F1bandwidth_sma3nz_stddevNorm',\n",
       " 'F1amplitudeLogRelF0_sma3nz_amean',\n",
       " 'F1amplitudeLogRelF0_sma3nz_stddevNorm',\n",
       " 'F2frequency_sma3nz_amean',\n",
       " 'F2frequency_sma3nz_stddevNorm',\n",
       " 'F2bandwidth_sma3nz_amean',\n",
       " 'F2bandwidth_sma3nz_stddevNorm',\n",
       " 'F2amplitudeLogRelF0_sma3nz_amean',\n",
       " 'F2amplitudeLogRelF0_sma3nz_stddevNorm',\n",
       " 'F3frequency_sma3nz_amean',\n",
       " 'F3frequency_sma3nz_stddevNorm',\n",
       " 'F3bandwidth_sma3nz_amean',\n",
       " 'F3bandwidth_sma3nz_stddevNorm',\n",
       " 'F3amplitudeLogRelF0_sma3nz_amean',\n",
       " 'F3amplitudeLogRelF0_sma3nz_stddevNorm',\n",
       " 'alphaRatioV_sma3nz_amean',\n",
       " 'alphaRatioV_sma3nz_stddevNorm',\n",
       " 'hammarbergIndexV_sma3nz_amean',\n",
       " 'hammarbergIndexV_sma3nz_stddevNorm',\n",
       " 'slopeV0-500_sma3nz_amean',\n",
       " 'slopeV0-500_sma3nz_stddevNorm',\n",
       " 'slopeV500-1500_sma3nz_amean',\n",
       " 'slopeV500-1500_sma3nz_stddevNorm',\n",
       " 'spectralFluxV_sma3nz_amean',\n",
       " 'spectralFluxV_sma3nz_stddevNorm',\n",
       " 'mfcc1V_sma3nz_amean',\n",
       " 'mfcc1V_sma3nz_stddevNorm',\n",
       " 'mfcc2V_sma3nz_amean',\n",
       " 'mfcc2V_sma3nz_stddevNorm',\n",
       " 'mfcc3V_sma3nz_amean',\n",
       " 'mfcc3V_sma3nz_stddevNorm',\n",
       " 'mfcc4V_sma3nz_amean',\n",
       " 'mfcc4V_sma3nz_stddevNorm',\n",
       " 'alphaRatioUV_sma3nz_amean',\n",
       " 'hammarbergIndexUV_sma3nz_amean',\n",
       " 'slopeUV0-500_sma3nz_amean',\n",
       " 'slopeUV500-1500_sma3nz_amean',\n",
       " 'spectralFluxUV_sma3nz_amean',\n",
       " 'loudnessPeaksPerSec',\n",
       " 'VoicedSegmentsPerSec',\n",
       " 'MeanVoicedSegmentLengthSec',\n",
       " 'StddevVoicedSegmentLengthSec',\n",
       " 'MeanUnvoicedSegmentLength',\n",
       " 'StddevUnvoicedSegmentLength',\n",
       " 'equivalentSoundLevel_dBp']"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "wd = '/kaggle/input/woz-speech/'\n",
    "#Set training and test folder paths\n",
    "training_path = wd+'features_train/features_train'\n",
    "test_path = wd+'features_test/features_test'\n",
    "\n",
    "#Load labels file\n",
    "labels = pd.read_csv(wd+'labels.csv')\n",
    "\n",
    "#Load feature description files, take out column 0 to use as header for training/test sets\n",
    "features = pd.read_csv(wd+'feature_description.csv', encoding_errors='ignore', header=None, index_col=0)\n",
    "features = features.index.tolist()\n",
    "features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "318ebbc2",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:52:58.448298Z",
     "iopub.status.busy": "2024-04-26T04:52:58.447913Z",
     "iopub.status.idle": "2024-04-26T04:52:58.455432Z",
     "shell.execute_reply": "2024-04-26T04:52:58.454272Z"
    },
    "papermill": {
     "duration": 0.017563,
     "end_time": "2024-04-26T04:52:58.457344",
     "exception": false,
     "start_time": "2024-04-26T04:52:58.439781",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def load_data(folder_path):\n",
    "    #Init empty dataframe\n",
    "    res = pd.DataFrame()\n",
    "    for file in os.listdir(folder_path):\n",
    "        #for each speaker file\n",
    "        if file.endswith('.csv'):\n",
    "            #get participant id from filename, eg filename: 'spk_305.csv'\n",
    "            participant = float(file.split('_')[1].split('.')[0])\n",
    "            #find labels for the participant\n",
    "            label = labels[labels['Participant_ID'] == participant]\n",
    "            #load participant feature file\n",
    "            file_path = os.path.join(folder_path, file)\n",
    "            data_df = pd.read_csv(file_path, header=None, names=features)\n",
    "            #Add labels and participant id columns\n",
    "            data_df['participant'] = participant\n",
    "            data_df['gender'] = label['Gender'].values[0]\n",
    "            data_df['depression'] = label['Depression'].values[0]\n",
    "            #combine everything to result\n",
    "            res = pd.concat([res, data_df])\n",
    "    return res"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "e8737082",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:52:58.473496Z",
     "iopub.status.busy": "2024-04-26T04:52:58.472533Z",
     "iopub.status.idle": "2024-04-26T04:52:59.698764Z",
     "shell.execute_reply": "2024-04-26T04:52:59.697765Z"
    },
    "papermill": {
     "duration": 1.236593,
     "end_time": "2024-04-26T04:52:59.700945",
     "exception": false,
     "start_time": "2024-04-26T04:52:58.464352",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "13626"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Load training data\n",
    "training_df = load_data(training_path)\n",
    "len(training_df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "5f58397d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:52:59.718490Z",
     "iopub.status.busy": "2024-04-26T04:52:59.718124Z",
     "iopub.status.idle": "2024-04-26T04:52:59.989028Z",
     "shell.execute_reply": "2024-04-26T04:52:59.988090Z"
    },
    "papermill": {
     "duration": 0.282002,
     "end_time": "2024-04-26T04:52:59.991585",
     "exception": false,
     "start_time": "2024-04-26T04:52:59.709583",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3280"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Load test data\n",
    "test_df = load_data(test_path)\n",
    "len(test_df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "6825c45e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:00.008707Z",
     "iopub.status.busy": "2024-04-26T04:53:00.007892Z",
     "iopub.status.idle": "2024-04-26T04:53:00.023325Z",
     "shell.execute_reply": "2024-04-26T04:53:00.022129Z"
    },
    "papermill": {
     "duration": 0.025985,
     "end_time": "2024-04-26T04:53:00.025778",
     "exception": false,
     "start_time": "2024-04-26T04:52:59.999793",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Missing value percent % for each column, total samples 13626\n",
      "F0semitoneFrom27.5Hz_sma3nz_amean             0.007339\n",
      "F0semitoneFrom27.5Hz_sma3nz_stddevNorm        0.007339\n",
      "F0semitoneFrom27.5Hz_sma3nz_percentile20.0    0.007339\n",
      "F0semitoneFrom27.5Hz_sma3nz_percentile50.0    0.007339\n",
      "F0semitoneFrom27.5Hz_sma3nz_percentile80.0    0.007339\n",
      "                                                ...   \n",
      "StddevUnvoicedSegmentLength                   0.007339\n",
      "equivalentSoundLevel_dBp                      0.007339\n",
      "participant                                   0.000000\n",
      "gender                                        0.000000\n",
      "depression                                    0.000000\n",
      "Length: 91, dtype: float64\n"
     ]
    }
   ],
   "source": [
    "# Check Missing values\n",
    "missing_values = (training_df.isnull().sum()/len(training_df)) *100\n",
    "print(f'Missing value percent % for each column, total samples {len(training_df)}')\n",
    "print(missing_values)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "23304217",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:00.042770Z",
     "iopub.status.busy": "2024-04-26T04:53:00.042046Z",
     "iopub.status.idle": "2024-04-26T04:53:00.053275Z",
     "shell.execute_reply": "2024-04-26T04:53:00.052263Z"
    },
    "papermill": {
     "duration": 0.021969,
     "end_time": "2024-04-26T04:53:00.055506",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.033537",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "13625"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "training_df = training_df.dropna()\n",
    "len(training_df)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0798a4b8",
   "metadata": {
    "papermill": {
     "duration": 0.007142,
     "end_time": "2024-04-26T04:53:00.070184",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.063042",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "There was only one row with null values so I think we're good to drop that row."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "19e9d3a5",
   "metadata": {
    "papermill": {
     "duration": 0.007099,
     "end_time": "2024-04-26T04:53:00.084619",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.077520",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Designating subjects as validation vs training subjects"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "18af797f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:00.101401Z",
     "iopub.status.busy": "2024-04-26T04:53:00.100416Z",
     "iopub.status.idle": "2024-04-26T04:53:00.106922Z",
     "shell.execute_reply": "2024-04-26T04:53:00.106117Z"
    },
    "papermill": {
     "duration": 0.017069,
     "end_time": "2024-04-26T04:53:00.108971",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.091902",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def val_split(df: pd.DataFrame):\n",
    "    df['participant'] = df['participant'].astype(int)\n",
    "    n = np.unique(df['participant'])\n",
    "    n_range = range(min(n), max(n))\n",
    "    train_subs = random.sample(n_range, math.floor(len(n)*0.75))\n",
    "    train = df[df['participant'].isin(train_subs)]\n",
    "    val = df[~df['participant'].isin(train_subs)]\n",
    "    return train, val"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "a3bf2476",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:00.125530Z",
     "iopub.status.busy": "2024-04-26T04:53:00.125181Z",
     "iopub.status.idle": "2024-04-26T04:53:00.140779Z",
     "shell.execute_reply": "2024-04-26T04:53:00.139894Z"
    },
    "papermill": {
     "duration": 0.02656,
     "end_time": "2024-04-26T04:53:00.143147",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.116587",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "train, val = val_split(training_df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "7e6a9c96",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:00.160257Z",
     "iopub.status.busy": "2024-04-26T04:53:00.159633Z",
     "iopub.status.idle": "2024-04-26T04:53:00.164155Z",
     "shell.execute_reply": "2024-04-26T04:53:00.163415Z"
    },
    "papermill": {
     "duration": 0.015191,
     "end_time": "2024-04-26T04:53:00.166100",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.150909",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "#Used to split into our features and our outcomes for this task\n",
    "def x_y_split(df: pd.DataFrame):\n",
    "    x = df.drop(['participant', 'gender', 'depression'], axis = 1)\n",
    "    gender = df['gender']\n",
    "    depression = df['depression']\n",
    "    return x, gender, depression"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "1fd69f14",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:00.182497Z",
     "iopub.status.busy": "2024-04-26T04:53:00.181879Z",
     "iopub.status.idle": "2024-04-26T04:53:00.197267Z",
     "shell.execute_reply": "2024-04-26T04:53:00.196184Z"
    },
    "papermill": {
     "duration": 0.026039,
     "end_time": "2024-04-26T04:53:00.199482",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.173443",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "x_train, g_train, d_train = x_y_split(train)\n",
    "x_val, g_val, d_val = x_y_split(val)\n",
    "x_test, g_test, d_test = x_y_split(test_df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "94fd9ead",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:00.216239Z",
     "iopub.status.busy": "2024-04-26T04:53:00.215871Z",
     "iopub.status.idle": "2024-04-26T04:53:00.225226Z",
     "shell.execute_reply": "2024-04-26T04:53:00.224219Z"
    },
    "papermill": {
     "duration": 0.020188,
     "end_time": "2024-04-26T04:53:00.227288",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.207100",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from sklearn.metrics import confusion_matrix\n",
    "# Calculates accuracy\n",
    "# pass true and predicted labels\n",
    "# return accuracy score\n",
    "def calculate_total_accuracy(true_labels, predicted_labels):\n",
    "    return accuracy_score(true_labels, predicted_labels)\n",
    "\n",
    "# Calculates accuracy\n",
    "# pass true and predicted labels\n",
    "# return balanced accuracy score\n",
    "def calculate_balanced_accuracy(true_labels, predicted_labels):\n",
    "    #calculkate confusion matrix\n",
    "    matrix = confusion_matrix(true_labels, predicted_labels)\n",
    "    TP = matrix[1, 1]\n",
    "    TN = matrix[0, 0]\n",
    "    FP = matrix[0, 1]\n",
    "    FN = matrix[1, 0]\n",
    "    #For positive class, how many correct predictions\n",
    "    accuracy_positive = TP/(TP+FN)\n",
    "    #For negative class how many \n",
    "    accuracy_negative = TN/(TN+FP)\n",
    "    return 0.5*(accuracy_positive + accuracy_negative)\n",
    "\n",
    "#Calculates Equality of Opportunity\n",
    "# pass true and predicted labels for male samples\n",
    "# pass true and predicted labels for female samples\n",
    "# return balanced accuracy score\n",
    "def calculate_EO(true_labels_male, \n",
    "                 true_labels_female,\n",
    "                 predicted_labels_male,\n",
    "                predicted_labels_female):\n",
    "    #Calculate True pistive rate for male gender with confusion matrix\n",
    "    matrix_male = confusion_matrix(true_labels_male, predicted_labels_male)\n",
    "    TP = matrix_male[1, 1]\n",
    "    TN = matrix_male[0, 0]\n",
    "    FN = matrix_male[1, 0]\n",
    "    TPR_male = TP/(TP+FN)\n",
    "\n",
    "    #Calculate True pistive rate for female gender with confusion matrix\n",
    "    matrix_female = confusion_matrix(true_labels_female, predicted_labels_female)\n",
    "    TP = matrix_female[1, 1]\n",
    "    TN = matrix_female[0, 0]\n",
    "    FN = matrix_female[1, 0]\n",
    "    TPR_female = TP/(TP+FN)\n",
    "    \n",
    "    # Calculate EO\n",
    "    return 1-abs(TPR_male-TPR_female) \n",
    "\n",
    "#Function to calculate majority votings\n",
    "#Pass labels\n",
    "#Returns mode or which label was predicted most\n",
    "def majority_voting(df):\n",
    "    counts = df.value_counts()\n",
    "    return counts.idxmax()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "14d87c3c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:00.244395Z",
     "iopub.status.busy": "2024-04-26T04:53:00.243713Z",
     "iopub.status.idle": "2024-04-26T04:53:00.254848Z",
     "shell.execute_reply": "2024-04-26T04:53:00.253807Z"
    },
    "papermill": {
     "duration": 0.022285,
     "end_time": "2024-04-26T04:53:00.257016",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.234731",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "#Function to calculate all metrics\n",
    "#Pass true labels, predicted labels and a reference(test/val) dataframe\n",
    "#referece dataframe should have all labels and features\n",
    "#Returns a dictionary with all the metric calculated\n",
    "def calculate_metrics(y_true, y_pred, test_data):\n",
    "    # Initialize metrics\n",
    "    metrics = {}\n",
    "    #---------------------------------------------------CALCULATING TOTAL METRICS\n",
    "    #calculate total accuracy\n",
    "    metrics[\"Total accuracy\"] = calculate_total_accuracy(y_true, y_pred)\n",
    "    #calculate total balanced accuracy\n",
    "    metrics[\"Total Balanced accuracy\"] = calculate_balanced_accuracy(y_true, y_pred)\n",
    "    #calculate total EO\n",
    "    #find gender based indices for true labels from data\n",
    "    male_indices = test_data[test_data['gender']==1].index\n",
    "    female_indices = test_data[test_data['gender']==0].index\n",
    "    #separate true labels based on indices\n",
    "    male_true = y_true.loc[male_indices]\n",
    "    female_true = y_true.loc[female_indices]\n",
    "    #Find the corresponding indices for predicted labels from true_labels\n",
    "    male_true_index_list = male_true.index.tolist()\n",
    "    female_true_index_list = female_true.index.tolist()\n",
    "    #Get separated predicted labels based on gender\n",
    "    male_predicted = y_pred[[male_true_index_list.index(index) for index in male_true_index_list]]\n",
    "    female_predicted = y_pred[[female_true_index_list.index(index) for index in female_true_index_list]]\n",
    "    metrics[\"Total EO\"] = calculate_EO(male_true, female_true, male_predicted, female_predicted)\n",
    "    #-------------------------------------------------CALCULATING AGGREGATED METRICS FOR EACH PARTICIPANT\n",
    "    predictions_df = pd.DataFrame({'participant': test_data['participant'], 'predicted_label': y_pred, 'true_label': y_true})\n",
    "    aggregated_y_true = predictions_df.groupby('participant')['true_label'].agg(majority_voting)\n",
    "    aggregated_y_pred = predictions_df.groupby('participant')['predicted_label'].agg(majority_voting)\n",
    "    #Calculate aggregated accuracy score\n",
    "    metrics[\"Aggregated accuracy score\"] = calculate_total_accuracy(aggregated_y_true, aggregated_y_pred)\n",
    "    #Calculate balanced aggregated accuracy\n",
    "    metrics[\"Aggregated balanced accuracy score\"] = calculate_balanced_accuracy(aggregated_y_true, aggregated_y_pred)\n",
    "    #Calculate aggregated EOs\n",
    "    male_predictions_df = pd.DataFrame({'participant': test_data['participant'].loc[male_indices], 'predicted_label': y_pred, 'true_label': y_true})\n",
    "    male_aggregated_y_true = male_predictions_df.groupby('participant')['true_label'].agg(majority_voting)\n",
    "    male_aggregated_y_pred = male_predictions_df.groupby('participant')['predicted_label'].agg(majority_voting)\n",
    "    female_predictions_df = pd.DataFrame({'participant': test_data['participant'].loc[female_indices], 'predicted_label': y_pred, 'true_label': y_true})\n",
    "    female_aggregated_y_true = female_predictions_df.groupby('participant')['true_label'].agg(majority_voting)\n",
    "    female_aggregated_y_pred = female_predictions_df.groupby('participant')['predicted_label'].agg(majority_voting)\n",
    "    metrics[\"Aggregated EO score\"] = calculate_EO(male_aggregated_y_true, female_aggregated_y_true, male_aggregated_y_pred, female_aggregated_y_pred)\n",
    "    \n",
    "    return metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c834f1f8",
   "metadata": {
    "papermill": {
     "duration": 0.00706,
     "end_time": "2024-04-26T04:53:00.271478",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.264418",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Feature selection"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b576ebed",
   "metadata": {
    "papermill": {
     "duration": 0.007029,
     "end_time": "2024-04-26T04:53:00.285957",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.278928",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Running PCA to find the principal components in the data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "8a50977e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:00.302068Z",
     "iopub.status.busy": "2024-04-26T04:53:00.301676Z",
     "iopub.status.idle": "2024-04-26T04:53:00.457540Z",
     "shell.execute_reply": "2024-04-26T04:53:00.456669Z"
    },
    "papermill": {
     "duration": 0.167164,
     "end_time": "2024-04-26T04:53:00.460319",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.293155",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from sklearn import decomposition\n",
    "from sklearn.feature_selection import SelectKBest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "0a9d92a0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:00.477280Z",
     "iopub.status.busy": "2024-04-26T04:53:00.476168Z",
     "iopub.status.idle": "2024-04-26T04:53:00.483757Z",
     "shell.execute_reply": "2024-04-26T04:53:00.482884Z"
    },
    "papermill": {
     "duration": 0.018176,
     "end_time": "2024-04-26T04:53:00.485815",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.467639",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "class PCA_(decomposition.PCA):\n",
    "    def __init__(self, x_train, x_val, x_test):\n",
    "        super().__init__()\n",
    "        self.x_train = x_train\n",
    "        self.x_val = x_val\n",
    "        self.x_test = x_test\n",
    "    \n",
    "    def run_pca(self):\n",
    "        #Find all PCs for the data\n",
    "        self.fit(self.x_train)\n",
    "        #Transform the data into the new feature space\n",
    "        self.x_train = self.transform(self.x_train)\n",
    "        self.x_val = self.transform(self.x_val)\n",
    "        self.x_test = self.transform(self.x_test)\n",
    "    \n",
    "    def best_PCs(self, Y, k):\n",
    "        #Find the k best PCs for predicting a given outcome Y\n",
    "        best = SelectKBest(k=k).fit(self.x_train, Y)\n",
    "        return best.transform(self.x_train), best.transform(self.x_val), best.transform(self.x_test)\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "e3ae1d5d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:00.503062Z",
     "iopub.status.busy": "2024-04-26T04:53:00.502074Z",
     "iopub.status.idle": "2024-04-26T04:53:00.580162Z",
     "shell.execute_reply": "2024-04-26T04:53:00.578965Z"
    },
    "papermill": {
     "duration": 0.089727,
     "end_time": "2024-04-26T04:53:00.583214",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.493487",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "pca = PCA_(x_train, x_val, x_test)\n",
    "pca.run_pca()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3d8d1bdb",
   "metadata": {
    "papermill": {
     "duration": 0.037078,
     "end_time": "2024-04-26T04:53:00.632159",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.595081",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Running independent component analysis to compare to PCA."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "020ae68f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:00.676536Z",
     "iopub.status.busy": "2024-04-26T04:53:00.675978Z",
     "iopub.status.idle": "2024-04-26T04:53:00.691495Z",
     "shell.execute_reply": "2024-04-26T04:53:00.690259Z"
    },
    "papermill": {
     "duration": 0.037723,
     "end_time": "2024-04-26T04:53:00.694897",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.657174",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "class ICA_(decomposition.FastICA):\n",
    "    def __init__(self, x_train, x_val, x_test):\n",
    "        super().__init__()\n",
    "        self.x_train = x_train\n",
    "        self.x_val = x_val\n",
    "        self.x_test = x_test\n",
    "    \n",
    "    def run_ica(self):\n",
    "        #Find all ICs for the data\n",
    "        self.fit(self.x_train)\n",
    "        #Transform the data into the new feature space\n",
    "        self.x_train = self.transform(self.x_train)\n",
    "        self.x_val = self.transform(self.x_val)\n",
    "        self.x_test = self.transform(self.x_test)\n",
    "    \n",
    "    def best_ICs(self, Y, k):\n",
    "        #Find the k best ICs for predicting a given outcome Y\n",
    "        best = SelectKBest(k=k).fit(self.x_train, Y)\n",
    "        return best.transform(self.x_train), best.transform(self.x_val), best.transform(self.x_test)\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "d02cc390",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:00.713967Z",
     "iopub.status.busy": "2024-04-26T04:53:00.713575Z",
     "iopub.status.idle": "2024-04-26T04:53:04.301506Z",
     "shell.execute_reply": "2024-04-26T04:53:04.300314Z"
    },
    "papermill": {
     "duration": 3.600868,
     "end_time": "2024-04-26T04:53:04.304883",
     "exception": false,
     "start_time": "2024-04-26T04:53:00.704015",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/conda/lib/python3.10/site-packages/sklearn/decomposition/_fastica.py:542: FutureWarning: Starting in v1.3, whiten='unit-variance' will be used by default.\n",
      "  warnings.warn(\n"
     ]
    }
   ],
   "source": [
    "ica = ICA_(x_train, x_val, x_test)\n",
    "ica.run_ica()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2bb523c7",
   "metadata": {
    "papermill": {
     "duration": 0.040958,
     "end_time": "2024-04-26T04:53:04.357673",
     "exception": false,
     "start_time": "2024-04-26T04:53:04.316715",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Linear Perceptron\n",
    "Create a linear perceptron from the PCs that best predict gender and depression."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "d0185158",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:04.403176Z",
     "iopub.status.busy": "2024-04-26T04:53:04.402611Z",
     "iopub.status.idle": "2024-04-26T04:53:04.409554Z",
     "shell.execute_reply": "2024-04-26T04:53:04.408475Z"
    },
    "papermill": {
     "duration": 0.027139,
     "end_time": "2024-04-26T04:53:04.412344",
     "exception": false,
     "start_time": "2024-04-26T04:53:04.385205",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from sklearn import linear_model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "888ac41e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:04.438228Z",
     "iopub.status.busy": "2024-04-26T04:53:04.437850Z",
     "iopub.status.idle": "2024-04-26T04:53:04.442564Z",
     "shell.execute_reply": "2024-04-26T04:53:04.441815Z"
    },
    "papermill": {
     "duration": 0.016947,
     "end_time": "2024-04-26T04:53:04.445943",
     "exception": false,
     "start_time": "2024-04-26T04:53:04.428996",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def perceptron(x_train, y_train, x_val, y_val):\n",
    "    percept = linear_model.Perceptron()\n",
    "    percept.fit(x_train, y_train)\n",
    "    preds = percept.predict(x_val)\n",
    "    return calculate_balanced_accuracy(y_val, preds)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "ba76af8a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:04.462715Z",
     "iopub.status.busy": "2024-04-26T04:53:04.462334Z",
     "iopub.status.idle": "2024-04-26T04:53:07.930543Z",
     "shell.execute_reply": "2024-04-26T04:53:07.929393Z"
    },
    "papermill": {
     "duration": 3.479973,
     "end_time": "2024-04-26T04:53:07.933535",
     "exception": false,
     "start_time": "2024-04-26T04:53:04.453562",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "For predicting gender with PCs, the best performance was achieved by using the 53 best PCs. This achieved a balanced accuracy of 0.8949249772238559\n",
      "For predicting gender with ICs, the best performance was achieved by using the 59 best ICs. This achieved a balanced accuracy of 0.9137404843144993\n"
     ]
    }
   ],
   "source": [
    "pc_g_stats = {}\n",
    "ic_g_stats = {}\n",
    "for k in range(1, 60):\n",
    "    g_x_train, g_x_val, g_x_test = pca.best_PCs(g_train, k)\n",
    "    pc_g_stats[k] = perceptron(g_x_train, g_train, g_x_val, g_val)\n",
    "    \n",
    "    g_x_train, g_x_val, g_x_test = ica.best_ICs(g_train, k)\n",
    "    ic_g_stats[k] = perceptron(g_x_train, g_train, g_x_val, g_val)\n",
    "\n",
    "g_n_pcs_best = max(pc_g_stats, key=pc_g_stats.get)\n",
    "g_acc_best = pc_g_stats[g_n_pcs_best]\n",
    "\n",
    "print('For predicting gender with PCs, the best performance was achieved by using the', g_n_pcs_best, 'best PCs. This achieved a balanced accuracy of', g_acc_best)\n",
    "\n",
    "g_n_ics_best = max(ic_g_stats, key=ic_g_stats.get)\n",
    "g_acc_best = ic_g_stats[g_n_ics_best]\n",
    "\n",
    "print('For predicting gender with ICs, the best performance was achieved by using the', g_n_ics_best, 'best ICs. This achieved a balanced accuracy of', g_acc_best)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "0994f473",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-04-26T04:53:07.961465Z",
     "iopub.status.busy": "2024-04-26T04:53:07.960168Z",
     "iopub.status.idle": "2024-04-26T04:53:11.075386Z",
     "shell.execute_reply": "2024-04-26T04:53:11.074260Z"
    },
    "papermill": {
     "duration": 3.13255,
     "end_time": "2024-04-26T04:53:11.078505",
     "exception": false,
     "start_time": "2024-04-26T04:53:07.945955",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "For predicting depression with PCs, the best performance was achieved by using the 39 best PCs. This achieved a balanced accuracy of 0.5391702774609333\n",
      "For predicting depression with ICs, the best performance was achieved by using the 7 best ICs. This achieved a balanced accuracy of 0.5718746985867613\n"
     ]
    }
   ],
   "source": [
    "pc_d_stats = {}\n",
    "ic_d_stats = {}\n",
    "for k in range(1, 60):\n",
    "    d_x_train, d_x_val, d_x_test = pca.best_PCs(d_train, k)\n",
    "    pc_d_stats[k] = perceptron(d_x_train, d_train, d_x_val, d_val)\n",
    "    \n",
    "    d_x_train, d_x_val, d_x_test = ica.best_ICs(d_train, k)\n",
    "    ic_d_stats[k] = perceptron(d_x_train, d_train, d_x_val, d_val)\n",
    "\n",
    "d_n_pcs_best = max(pc_d_stats, key=pc_d_stats.get)\n",
    "d_acc_best = pc_d_stats[d_n_pcs_best]\n",
    "\n",
    "print('For predicting depression with PCs, the best performance was achieved by using the', d_n_pcs_best, 'best PCs. This achieved a balanced accuracy of', d_acc_best)\n",
    "\n",
    "d_n_ics_best = max(ic_d_stats, key=ic_d_stats.get)\n",
    "d_acc_best = ic_d_stats[d_n_ics_best]\n",
    "\n",
    "print('For predicting depression with ICs, the best performance was achieved by using the', d_n_ics_best, 'best ICs. This achieved a balanced accuracy of', d_acc_best)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1d4982f1",
   "metadata": {
    "papermill": {
     "duration": 0.011901,
     "end_time": "2024-04-26T04:53:11.102964",
     "exception": false,
     "start_time": "2024-04-26T04:53:11.091063",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 4864172,
     "sourceId": 8208545,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 30698,
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.13"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 30.503975,
   "end_time": "2024-04-26T04:53:12.553356",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2024-04-26T04:52:42.049381",
   "version": "2.5.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
